\chapter{Evaluation}
\label{ch:evaluation}

\section{Testing}
Testing was performed throughout the development of the application. This has mainly been manual testing focused on unit tests such that each component completes its intended purpose and is robust. Some integration testing and error handling was also implemented to ensure the application can handle unexpected behaviour.

\subsection{Unit Testing}
Unit tests were performed in sandbox mode throughout the implementation to ensure that each component and API route performed as expected. As well as this, some unit tests were attempted in development mode, but this is a lot more difficult to test as there is a limited amount of credentials for Plaid, and the data is live transactional data, so constantly changing. Similarly, for the budget prediction, there is a limited amount of data to use, and most of it was used for training.

\subsection{Integration Testing}
On top of unit testing, integration testing ensures that each application part works together as expected. Each strategy was tried with every bank account available on sandbox mode and as many bank accounts available on development mode. In addition, anywhere there was user input, all input types were tested; this includes valid, erroneous and edge cases. Ideally, this would have been done with a test suite, but this was not attempted due to time constraints and minimal areas where users can input anything.


\subsection{Graceful Error Handling}
As mentioned previously (\ref{sec:endpoints}), each endpoint only performs its intended purpose or fails. This allows the error handling to be done client-side to reduce unexpected behaviour and cleaner code. On the client-side, the user is directed to an error page if anything fails. Almost always, if the user retries their actions, it will work, so this error page has a redirect button back to the dashboard.


\section{Other Considerations}

\subsection{Strategies}
As shown in figure \ref{fig:Endpoints}, a "get\_balances" API call was also implemented to access the balances for all toggled accounts. The widget to display on the dashboard was also implemented such that it could easily be added and matched the style of the other widgets. In the end, however, it was decided not to be included. Although it would have been helpful to the user to get a better overview of their finances and improve financial capability, it did not have an appropriate location to be put anywhere on the dashboard and would clutter up the UI. Making the minimal design means only the relevant information is shown to the user so they can get the minimal information they need on a complex topic.

As well as a balances widget, other functionality was also considered to be included in the web application. Examples include adding an income tracker to calculate precisely how much money would be earned after tax and other loans, as this was found to be quite a prevalent feature of other financial tools. In the aim to again have a minimal UI but also complete the project in time, the other strategies were prioritised over this due to their better effects in improving financial capability.

The budget strategy utilised the budget prediction, but as outlined in the design chapter (\ref{ch:design}), another option was to utilise the research on the 50:30:20 budgeting solution. The idea was to have a way for the user to split their recent transactions into these three buckets to identify where money could be spent and saved. This would have been an excellent way to improve financial capability and was considered to be implemented; however, the budget prediction was a more exciting and challenging feature to implement and so was prioritised. Unlike the other widgets, this design could have been implemented on top of the budget prediction as part of the same strategy, but due to time constraints, this was not attempted.

\subsection{Budget Prediction}
The current solution for budget prediction is one model trained on the developer's financial data. This is acknowledged as not the best solution, but the system can be improved if more and various data sources can be accessed. An ideal design would have been implemented with two different neural networks.

The first would have been a macro model. This would have been trained on several, and ideally many, different users' data. It would aim to identify the macro trends in expenditure, for example, the cost of living crisis, and the patterns it identifies would be incorporated into the prediction.

On top of the macro model, there also would be a micro model, which is trained per user. When users sign up, they will be asked if they consent to a personalised model being trained on their data. If they accept, an independent micro model on the server would be created based on only their transactional behaviour.

The predictions made when utilising the budget strategy would incorporate the macro trends and the individual's micro patterns to give a more accurate prediction. This macro/micro model structure was inspired by the research into time series prediction when some papers focus on macro prediction and others focus on micro prediction.

\section{Project Management}
The project utilised a hybrid approach of research methodologies in the first phase, the waterfall methodology in the second phase, a general agile methodology in the third phase, and an extreme programming-like methodology in the final phase. The first three phases were intelligently chosen based on the work done in each phase to synergise well. However, the final phase was less so chosen but more a result of what happened, so in retrospect, a more detailed plan would have been better to give it more structure.

In addition, this four-phase plan was the second plan that was created. The first one, designed in the specification, was too ambitious and did not include certain aspects of the project that were later essential, such as budget prediction. This was a factor of not having a concrete plan of what the software should do, but also from little experience in project management for a software project. Now, with this experience, a better plan could be constructed. Furthermore, it is also clear that deciding precisely what the software should do is a crucial part that should come before the final timetable is created.