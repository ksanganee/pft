\chapter{Evaluation}
\label{ch:evaluation}

\section{Testing}
Testing was performed throughout the development of the application. This has mainly been manual testing and has focused on unit tests such that each component completes its intended purpose and is robust. Some integration testing and error handling was also implemented to ensure the application can handle unexpected behaviour.

\subsection{Unit Testing}
Throughout the implementation, unit tests were were performed in sandbox mode to ensure that each individual component and API route performed as expected. As well as this, some unit tests were attempted in development mode, but this is a lot more difficult to test as have a limited amount of credentials for Plaid, and the data is live transactional data so every changing. Similarly, for the budget prediction, there is a limited amount of data to use at all, and the majority of it is used for training.

\subsection{Integration Testing}
On top of unit testing, integration testing was performed by ensuring that each part of the application works together as expected. Each strategy was tried with every bank account available on sandbox mode, and as many bank accounts available on development mode. In addition, anywhere there was user input, all types of input were tested, this include valid, erroneous and edge cases. Ideally, this would have been done with a test suite, but due to time constraints and minimal areas where the user can input anything, this was not attempted.


\subsection{Graceful Error Handling}
As mentioned previously (\ref{sec:endpoints}), each endpoint can only performs its intended purpose or fail. This allows the error handling to be done client-side to reduce unexpected behaviour, as well as cleaner code. On the client-side if anything fails, the user is directed to an error page. Almost always, if the user retries their actions, it will work so this error page just has a redirect back to the dashboard.


\section{Other Considerations}

\subsection{Strategies}
As shown in figure \ref{fig:Endpoints}, a "get\_balances" API call was also implemented to access the balances for all toggled accounts. The widget to display on the dashboard was also implemented such that it could easily be added and matched the style of the other widgets. In the end, however, it was decided not to be included. Although it would have been helpful to the user to get a better overview of their finances and so improve financial capability, it didn't have an appropriate location to be put anywhere on the dashboard, and would just clutter up the UI. By making the design minimal, this means only the relevant information is shown to the user and so they can get the minimal information they need in a complex topic.

As well as a balances widget, other functionality was also considered to be included in the web application. This includes adding an income tracker to be able to calculate exactly how much money would be earned after tax and other loans, as this was found to be quite an important feature of other finance tools. In the aim to again have a minimal UI, but also complete the project in time, the other strategies were prioritised over this due to their better effects in improving financial capability.

The budget strategy utilised the budget prediction, but as outlined in the design chapter (\ref{ch:design}), another option was to utilise the research on the 50:30:20 budgeting solution. The idea was to have a way where the user could split their recent transactions into these three buckets as a task to identify where money could be spent and saved. This would have been a good way to improve financial capability and was considered to be implemented, but the budget prediction was a more interesting and challenging feature to implement and so was prioritised. Unlike the other widgets, this design could have been implemented on top of the budget prediction as part of the same strategy but due to time constraints this was not attempted.

\subsection{Budget Prediction}
The current solution for budget prediction is one model that is trained on the financial data of the developer. This is acknowledged as not the best solution, but the system is there to be improved if more and various data could be accessed. The more ideal design that would have been implemented with two different neural networks.

The first would have been a macro model. This would have been trained on several, and ideally many, different users' data. It would aim to identify the macro trends in expenditure, for example the cost of living crisis, and the patterns it identifies would be incorporated into the prediction.

On top of the macro model, there also would be a micro model which is trained on a per user basis. When a user signs up, they would be asked if they consent to a personalised model being trained on their data. If they accept, on the server, an independent micro model would be created based on only their transactional behaviour.

The actual predictions that would be made when utilising the budget strategy would incorporate the macro trends as well as the individual's micro patterns to give a more accurate prediction. This macro/micro model structure was inspired by the research into time series prediction when some papers focus on macro prediction and others focus on micro prediction.

\section{Project Management}
The project utilised a hybrid approach by using research methodologies in the first phase, the waterfall methodology in the second phase, a general agile methodology in the third phase, and an extreme programming-like methodology in the final phase. The first three phases were intelligently chosen based on the work that was done in each phase, to synergise well. The final phase was less chosen, but more a result of what actually happened, so in retrospect, a more detailed plan would have been better to give it more structure.

In addition, this four phase plan was the second plan that was created. The first one, designed in the specification, was too ambitious and also did not include certain aspects of the project that were later essential, such as the budget prediction. This was a factor of not having a concrete plan initially of what the software should do, but also little experience in project management for a software project. Now, with this experience, a better plan could be constructed. Furthermore, it is also clear that deciding on exactly what the software should do is a crucial part that should come before the final timetable is created.